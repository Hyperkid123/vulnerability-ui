import './Systems.scss';
import qs from 'query-string';
import propTypes from 'prop-types';
import { injectIntl } from 'react-intl';
import messages from '../../../Messages';
import { useDispatch } from 'react-redux';
import { withRouter } from 'react-router-dom';
import React, { useState, useEffect } from 'react';
import { dataShape } from '../../../Helpers/MiscHelper';
import { middlewareListener } from '../../../Utilities/ReducerRegistry';
import selectAllCheckbox from '../../../Helpers/selectAllCheckboxHelper';
import { PrimaryToolbar } from '@redhat-cloud-services/frontend-components';
import searchFilter from '../../PresentationalComponents/Filters/PrimaryToolbarFilters/SearchFilter';
import { fetchSystems, optOutSystemsAction } from '../../../Store/Actions/Actions';
import { addNotification } from '@redhat-cloud-services/frontend-components-notifications';
import { downloadFile } from '@redhat-cloud-services/frontend-components-utilities/files/helpers';
import { kebabAction, exportConfig, buildActiveFilters, removeFilters } from '../../../Helpers/TableToolbarHelper';

/*eslint camelcase: 0*/
const SystemsTableToolbar = (props) => {
    const [filter, setFilter] = useState(undefined);
    const [opt_out, setOptOut] = useState(false);
    const [page_size] = useState(10);
    const [page, setPage] = useState(1);
    const dispatch = useDispatch();

    const onSelect = (payload) => {
        const isInArray = props.selectedHosts.some(item => item === payload.data.id);

        if (!isInArray) {
            const newSelected = payload.data.selected ? [payload.data.id, ...props.selectedHosts]
                : props.selectedHosts.filter(item => item !== payload.data.id);
            props.handleSelect(false, newSelected);
        }
    };

    // eslint-disable-next-line no-unused-vars
    const [selectListener] = useState(middlewareListener.addNew({
        on: 'SELECT_ENTITY',
        callback: payload => onSelect(payload)
    }));

    useEffect(()=>{
        props.setSelectedHosts([]);
        dispatch(fetchSystems({ filter, page, page_size, opt_out }));
    }, [opt_out]);

    const createUrlParams = allParams => {
        const params = { ...allParams };
        const allowedParams = ['filter', 'page', 'page_size'];
        Object.keys(allParams).forEach(
            key =>
                (params[key] === undefined || params[key] === '' || !allowedParams.includes(key) || params[key] === false) &&
                delete params[key]
        );
        const queryString = qs.stringify(params);

        setFilter(allParams.filter);
        props.history.push('?' + queryString);
    };

    const downloadReport = format => {
        const { payload } = fetchSystems({
            opt_out,
            filter,
            data_format: format,
            page: 1,
            page_size: Number.MAX_SAFE_INTEGER
        });
        payload &&
            payload.then(({ data: response }) => {
                const data = format === 'json' ? JSON.stringify(response) : response;
                return downloadFile(data, `systems-${new Date().toISOString()}`, format);
            });
    };

    const doOptOut = () => {
        if (props.selectedHosts.length > 0) {
            dispatch(optOutSystemsAction(props.selectedHosts, !opt_out)).then(() => {
                dispatch(fetchSystems({ filter, opt_out, page_size, page: 1 }));
                opt_out === false
                    ? dispatch(addNotification({
                        variant: 'success',
                        title: this.props.intl.formatMessage(
                            messages.systemsExcludedNotification,
                            { count: props.selectedHosts.length || 0 }
                        )
                    }))
                    : dispatch(addNotification({
                        variant: 'success',
                        title: this.props.intl.formatMessage(
                            messages.systemsResumedNotificationTitle,
                            { count: props.selectedHosts.length || 0 }
                        ),
                        description: this.props.intl.formatMessage(messages.systemsResumedNotificationBody)
                    }));
                props.setSelectedHosts([]);
            });
        }
    };

    const handleRefresh = ({ page, page_size, filter }, callback) => {
        const { meta } = props.systems;
        if (meta.page !== page || meta.page_size !== page_size) {
            const config = {
                page,
                page_size: page_size || meta.page_size,
                filter,
                opt_out
            };
            createUrlParams(config);
            if (callback) {return callback(config);}
        }
    };

    const handleOptOut = () => {
        setOptOut(!opt_out);
        setPage(1);
    };

    const kebabOptions = [
        '',
        kebabAction(opt_out ? props.intl.formatMessage(messages.kebabResumeAnalysis)
            : props.intl.formatMessage(messages.kebabExcludeVulnerabilityAnalysis),

        () => doOptOut(opt_out), !props.selectedHosts.length),
        kebabAction(opt_out ? props.intl.formatMessage(messages.kebabHideExcludedSystems)
            : props.intl.formatMessage(messages.kebabShowExcludedSystems),
        () => handleOptOut(opt_out))
    ];

    const selectOptions = selectAllCheckbox({
        selectedItems: props.selectedHosts,
        selectorHandler: props.handleSelect,
        items: props.systems,
        fetchResource: ops =>handleRefresh(ops, (config) => fetchSystems(config))
    });

    return (
        <PrimaryToolbar
            bulkSelect={{
                count: props.selectedHosts.length,
                items: selectOptions.items,
                checked: Boolean(props.selectedHosts.length),
                onSelect: () => selectOptions.handleOnCheckboxChange()
            }}
            actionsConfig={{
                actions: kebabOptions,
                dropdownProps: { className: 'custom-class' }
            }}
            filterConfig={{
                items: [
                    searchFilter(props.intl.formatMessage(messages.searchLabel), filter, (f) => handleRefresh(f, props.onRefresh))
                ]
            }}
            activeFiltersConfig={{
                filters: buildActiveFilters(props.params),
                onDelete: (e, i) => removeFilters(i, (f) => handleRefresh(f, props.onRefresh))
            }}
            exportConfig={exportConfig({ downloadReport })}
        >
        </PrimaryToolbar>

    );

};

SystemsTableToolbar.propTypes = {
    systems: dataShape,
    history: propTypes.object,
    onRefresh: propTypes.any,
    selectedHosts: propTypes.object,
    setSelectedHosts: propTypes.func,
    handleSelect: propTypes.func,
    params: propTypes.object,
    intl: propTypes.any
};

export default withRouter(
    injectIntl(SystemsTableToolbar)
);

